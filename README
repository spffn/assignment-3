--- README ---

Taylor Clark
CS 4760
Assignment #3
Semaphores and Operating System Shell Simulator 

---

In this project I created an empty shell of an OS simulator and do some very basic tasks in preparation for a more comprehensive simulation later. It uses fork, exec, shared memory and semaphores.

This project (as far as I can tell) meets all the requirements of the project specifications. However, it should be noted that the forking off of children by oss in the loop, often fails after having created ~20+ children over the course of the programs life. This happens regardless of starting with 5 or 19 initial child spawns. I am not entirely sure why this is. 

This project catches Ctrl-C and cleans up resources as needed.

--- TO COMPILE ---
Run the makefile to compile both oss and child.


--- TO RUN ---
./(program name) -(any required command line arguments) (their values, if needed)
EX: ./oss -t 20

--- GITHUB ---

	https://github.com/spffn/assignment-3

	
--- DESCRIPTIONS ---

-- oss

	First allocates shared memory for a clock that only it will increment in user definable amounts. The child processes should be able to view this memory but will not increment it. This shared memory clock should be two integers, with one integer to hold seconds, the other integer to hold nanoseconds. So if one integer has 5 and the other has 10000 then that would mean that the clock is showing 5 seconds and 10000 nanoseconds. This clock should initially be set to 0.
	
	In addition to this shared memory clock, there should be an additional area of shared memory allocated to allow the child processes to send information to the master called shmMsg.

	With the clock at zero, oss should fork off the appropriate number of child processes to start then it should enter into a loop. Every iteration of that loop, it should increment the clock (simulating time passing in our system). While in this loop, oss should be checking shmMsg. If it has been sent a message from the child, it should output the contents of that message (which should be a set of two integers, a value in our clock) to a file. If there is a message in shmMsg, that means that the child process is terminating, so oss should then fork off another child and clear shmMsg. This process should continue until 2 seconds have passed in the simulated system time, 100 processes in total have been generated or the executable has been running for the maximum time allotted (in real seconds). At that point the master should terminate all children and then itself, while making sure to clean up any shared memory and semaphores it is using.

	Log file outputs as: 
		Master: Child (pid) is terminating at Master time xx.yy | Message recieved at mm.nn.
	
	with xx.yy being the time in the simulated system clock when oss received the message and mm.nn is the time that the user process put in shmMsg.
	
	At the start of the file, Master outputs loop start time in real time. At the end of the file, Master outputs total children spawned, end time in both real and simulated time.
	
	COMMAND LINE ARGUMENTS:
	
		-i: Will set the simuation clock increment in nanoseconds.
			Default is 50 nanoseconds
			Ex. -i 40,000
		-h: Show help. This shows all the accepted command lines arguments for this
			version of the program.
		-l: Will allow you to specify the filename to use as log file.
			By default, it is log.out.
			Do not include the extension (which will always be .out).
			Ex. -l newlog
		-o: Will allow you to specify the simulated time to end.
			By default, it is 2 simulated seconds.
			Ex. -o 10
		-s: Will set the maximum number of processes to spawn.
			Default is 5.
			Ex. -s 9
		-t: Will set the amount of real life time to wait before program termination.
			Default is 20 seconds.
			Ex. -t 60

-- child

	The child processes of the oss are the user processes. These should be a separate executable from master, run with exec from the fork of oss.
	This process should start by reading the simulated time system clock generated by oss. It should then generate a random duration number from 1 to 1000000 and add this to the time it got from the clock. This represents the time when this process should terminate itself.

	It should then loop continually over a critical section of code. This critical section should be enforced through the use of semaphores. Each iteration over the critical section, the user processes should examine the oss managed clock and see if its until that duration has passed. If while in the critical section it sees that its duration is up and there is nothing already in shmMsg, it should send a message to oss that it is going to terminate. Once it has put a message in shmMsg it should terminate itself, making sure to cede the critical section to any other user processes before doing so. If shmMsg is not empty the user process should cede the critical section and then on the next time it enters the critical section try and terminate at that time.

	This checking of duration vs oss clock and putting a message in the shmMsg for master should only occur in the critical section. If a user process gets inside the critical section and sees that its duration has not passed, it should cede the critical section to someone else and attempt to get back in the critical section.
	
-- semnam.h
	
	This file contains the information necessary for the creation of the named semaphore in the project. If for some reason, sem_open(3) fails with the "file already exists" error, change the name of the semaphore to any desired name and compile again.
	
	Ex: #define SEM_NAME "/semaName" --> #define SEM_NAME "/newSemName"